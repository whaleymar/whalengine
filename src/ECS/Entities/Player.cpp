#include <cstring>
#include "ECS/Components/AnimUtil.h"
#include "ECS/Components/Animator.h"
#include "ECS/Components/Draw.h"
#include "ECS/Components/PlayerControl.h"
#include "ECS/Components/Position.h"
#include "ECS/Components/RigidBody.h"
#include "ECS/Components/Velocity.h"
#include "ECS/Lib/ECS.h"

#include "Gfx/GfxUtil.h"

namespace whal {

// TODO this could be simplified. Ideally this should be read from a file generated by aseprite?
// File would look something like this:
// "basename","count", "secondsPerFile"
// "actor/player-run","4", "0.25"
// "actor/player-idle", "2", "1.0"
//
// this way, the only thing stored in code is animation names. Changing # of frames and file names is trivial
//
// per-frame duration could also be interesting, for a key-frame-like effect

namespace PlayerAnim {

const char* IDLE = "actor/player-idle";
const char* RUN = "actor/player-run";

// TODO switch to enums for comparisons in this func + animator setter
bool trySetAnimation(Animator& animator, const char* animName) {
    if (strcmp(animator.getAnimation().name, animName) != 0) {
        animator.setAnimation(animName);
        animator.resetAnimation();
        return true;
    }
    return false;
}

// interesting concept to try:
// *transition animations*
// -> animations which play for a fixed # of cycles & knows which animation follows? Maybe a custom data structure is overkill & we only need a static
// nCyclesRemaining var in brain?
//
// struct TransitionAnimation : Animation {
//     s32 nCyclesMax = 1;
//     s32 nextAnimIx = -1;
// };
//
bool brain(Animator& animator, ecs::Entity entity) {
    auto& rb = entity.get<RigidBody>();
    auto& vel = entity.get<Velocity>();
    auto& sprite = entity.get<Sprite>();
    // f32 frameCompletion = animator.curFrameDuration/animator.getAnimation().secondsPerFrame;
    // idea: duration of current animation, use that for stretch and squish, not frame
    if (vel.total.x() != 0) {
        if (rb.collider.isGrounded()) {
            if (trySetAnimation(animator, RUN)) {
                return true;
            }
        } else {
            if (rb.isJumping) {
                if (trySetAnimation(animator, IDLE)) {  // TODO jumping
                    return true;
                }
            } else {
                if (trySetAnimation(animator, IDLE)) {  // TODO falling
                    return true;
                }
            }
        }
    } else {
        if (trySetAnimation(animator, IDLE)) {
            return true;
        }
    }

    // animation did not change
    return basicAnimation(animator, entity);
}

}  // namespace PlayerAnim

Expected<ecs::Entity> createPlayer() {
    auto& ecs = ecs::ECS::getInstance();

    auto expected = ecs.entity();
    if (!expected.isExpected()) {
        return expected;
    }
    auto player = expected.value();
    Position position = Position::tiles(15, 10);
    player.add(position);
    player.add<Velocity>();
    player.add<PlayerControlRB>();
    // player.add<PlayerControlFree>();

    // graphics
    Animator animator;
    AnimInfo animInfo = {{PlayerAnim::RUN, 4, 0.25}, {PlayerAnim::IDLE, 2, 1.0}};  // TODO read from file
    loadAnimations(animator, animInfo);
    animator.brain = &PlayerAnim::brain;
    player.add(animator);

    Sprite sprite = Sprite(Depth::Player, animator.getFrame());
    player.add(sprite);

    constexpr s32 width = 16;
    constexpr s32 height = 16;
    constexpr s32 halfLenX = PIXELS_PER_TEXEL * width / 4;
    constexpr s32 halfLenY = PIXELS_PER_TEXEL * height / 2;
    player.add<RigidBody>(RigidBody(toFloatVec(position.e) + Vector2f(0, halfLenY), halfLenX, halfLenY));

    return player;
}

}  // namespace whal
