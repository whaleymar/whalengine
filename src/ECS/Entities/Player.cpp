#include "ECS/Components/AnimUtil.h"
#include "ECS/Components/Animator.h"
#include "ECS/Components/Draw.h"
#include "ECS/Components/PlayerControl.h"
#include "ECS/Components/Position.h"
#include "ECS/Components/RigidBody.h"
#include "ECS/Components/Velocity.h"
#include "ECS/Lib/ECS.h"
#include "Systems/Deltatime.h"
#include "Util/MathUtil.h"

#include "Gfx/GfxUtil.h"

namespace whal {

// TODO this could be simplified. Ideally this should be read from a file generated by aseprite?
// File would look something like this:
// "basename","count", "secondsPerFile"
// "actor/player-run","4", "0.25"
// "actor/player-idle", "2", "1.0"
//
// this way, the only thing stored in code is animation names. Changing # of frames and file names is trivial
//
// per-frame duration could also be interesting, for a key-frame-like effect

namespace PlayerAnim {

const char* IDLE = "actor/player-idle";
const char* RUN = "actor/player-run";
const char* JUMP = "actor/player-jump";
const char* FALL = "actor/player-fall";

// interesting concept to try:
// *transition animations*
// -> animations which play for a fixed # of cycles & knows which animation follows? Maybe a custom data structure is overkill & we only need a static
// nCyclesRemaining var in brain?
//
// struct TransitionAnimation : Animation {
//     s32 nCyclesMax = 1;
//     s32 nextAnimIx = -1;
// };
//
bool brain(Animator& animator, ecs::Entity entity) {
    auto& rb = entity.get<RigidBody>();
    auto& vel = entity.get<Velocity>();
    auto& sprite = entity.get<Sprite>();
    // f32 frameCompletion = animator.curFrameDuration/animator.getAnimation().secondsPerFrame;
    // idea: duration of current animation, use that for stretch and squish, not frame

    f32 unsquishStep = Deltatime::getInstance().get() * 1.75;
    sprite.scale = {approach(sprite.scale.x(), 1.0, unsquishStep), approach(sprite.scale.y(), 1.0, unsquishStep)};
    sprite.isVertsUpdateNeeded = true;
    if (rb.collider.isGrounded()) {
        if (rb.isLanding) {
            sprite.scale = {1.2, 0.8};  // TODO base on landing speed
        }
        if (vel.total.x() != 0) {
            if (animator.setAnimation(RUN)) {
                return true;
            }
        } else {
            if (animator.setAnimation(IDLE)) {
                return true;
            }
        }
    } else {
        if (rb.isJumping) {
            if (animator.setAnimation(JUMP)) {
                sprite.scale = {0.8, 1.2};
                return true;
            }
        } else {
            if (animator.setAnimation(FALL)) {
                return true;
            }
        }
    }

    // animation did not change
    return basicAnimation(animator, entity);
}

}  // namespace PlayerAnim

Expected<ecs::Entity> createPlayer() {
    auto& ecs = ecs::ECS::getInstance();

    auto expected = ecs.entity();
    if (!expected.isExpected()) {
        return expected;
    }
    auto player = expected.value();
    Position position = Position::tiles(15, 10);
    player.add(position);
    player.add<Velocity>();
    player.add<PlayerControlRB>();
    // player.add<PlayerControlFree>();

    // graphics
    Animator animator;
    AnimInfo animInfo = {
        {PlayerAnim::RUN, 4, 0.25},
        {PlayerAnim::IDLE, 2, 1.0},
        {PlayerAnim::JUMP, 1, 1.0},
        {PlayerAnim::FALL, 1, 1.0},
    };  // TODO read from file
    loadAnimations(animator, animInfo);
    animator.brain = &PlayerAnim::brain;
    player.add(animator);

    Sprite sprite = Sprite(Depth::Player, animator.getFrame());
    player.add(sprite);

    constexpr s32 width = 16;
    constexpr s32 height = 16;
    constexpr s32 halfLenX = PIXELS_PER_TEXEL * width / 4;
    constexpr s32 halfLenY = PIXELS_PER_TEXEL * height / 2;
    player.add<RigidBody>(RigidBody(toFloatVec(position.e) + Vector2f(0, halfLenY), halfLenX, halfLenY));

    return player;
}

}  // namespace whal
