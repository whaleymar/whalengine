#include "Player.h"

#include "ECS/Components/Animator.h"
#include "ECS/Components/Draw.h"
#include "ECS/Components/PlayerControl.h"
#include "ECS/Components/Position.h"
#include "ECS/Components/RigidBody.h"
#include "ECS/Components/Velocity.h"
#include "ECS/Lib/ECS.h"
#include "Gfx/GLResourceManager.h"
#include "Gfx/GfxUtil.h"
#include "Util/Print.h"

namespace whal {

// TODO this could be simplified. Ideally this should be read from a file generated by aseprite?
static std::array<const char*, 4> animFramesRun = {"actor/player-run1", "actor/player-run2", "actor/player-run3", "actor/player-run4"};

void loadAnimations(std::vector<Animation>& dstAnims) {
    std::vector<Frame> frames;
    auto& spriteTexture = GLResourceManager::getInstance().getTexture(TEXNAME_SPRITE);

    // TODO function
    for (auto& animName : animFramesRun) {
        auto frame = spriteTexture.getFrame(animName);
        if (frame) {
            frames.push_back(*frame);
        } else {
            print("Failed to load animation frame: ", animName);
        }
    }

    Animation anim = Animation("run", frames);
    dstAnims.push_back(anim);
}

ecs::Entity createPlayer() {
    auto& ecs = ecs::ECS::getInstance();

    auto player = ecs.entity().value();
    player.add<Position>(Position::tiles(15, 10));
    player.add<Velocity>();
    player.add<PlayerControlRB>();
    // entity.add<PlayerControlFree>();

    // graphics
    s32 width = 16;
    s32 height = 16;
    auto playerDraw = Sprite();
    playerDraw.setFrameSize(width, height);
    // playerDraw.setColor(Color::EMERALD);
    player.add<Sprite>(playerDraw);

    std::vector<Animation> anims;
    loadAnimations(anims);
    player.add<Animator>(Animator(anims));

    auto halfLenX = PIXELS_PER_TEXEL * width / 4;
    auto halfLenY = PIXELS_PER_TEXEL * height / 2;
    player.add<RigidBody>(RigidBody(toFloatVec(player.get<Position>().e), halfLenX, halfLenY));

    return player;
}

}  // namespace whal
